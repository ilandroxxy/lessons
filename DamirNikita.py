# region Домашка: ******************************************************************


# endregion Домашка: ******************************************************************
# #
# #
# region Урок: ********************************************************************


# № 23764 Демоверсия 2026 (Уровень: Базовый)
#
# Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
# – символ «?» означает ровно одну произвольную цифру;
# – символ «*» означает любую последовательность цифр произвольной длины; в том числе «*» может задавать и пустую последовательность.

# Среди натуральных чисел, не превышающих 10**10, найдите все числа,
# соответствующие маске 3?12?14*5, делящиеся на 1917 без остатка.

# В ответе запишите в первом столбце таблицы все найденные числа в
# порядке возрастания, а во втором столбце – соответствующие им
# результаты деления этих чисел на 1917.
'''
from fnmatch import *
for x in range(1917, 10**10, 1917):
   if fnmatch(str(x), '3?12?14*5'):
        print(x, x // 1917)
'''


# № 21718 ЕГКР 19.04.25 (Уровень: Базовый)

# Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
# - символ «?» означает ровно одну произвольную цифру;
# - символ «*» означает любую последовательность произвольной длины; в том числе «*» может задавать и пустую последовательность.

# Среди натуральных чисел, не превышающих 10**10, найдите все числа, соответствующие маске 4*4736*1,
# которые делятся на 7993 без остатка. В ответе запишите в первом столбце таблицы все найденные числа
# в порядке возрастания, а во втором столбце - соответствующие им результаты деления этих чисел на 7993.
'''
from fnmatch import *
for x in range(7993,10**10,7993):
    if fnmatch(str(x), "4*4736*1"):
        print(x,x//7993)
'''


# (Н. Сафронов) Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
# — символ «?» означает ровно одну произвольную цифру;
# — символ «*» означает любую последовательность цифр произвольной длины; в том числе «*» может задавать и пустую последовательность.

# Найдите все натуральные числа, не превосходящие 107, для которых выполняются одновременно все условия:

# • соответствуют маске *2?2*;

# • являются палиндромами;

# • делятся на число 53 без остатка;

# • количество делителей больше 30.

# В ответе запишите в первом столбце таблицы все найденные числа в порядке возрастания, а во втором столбце — сумму делителей.
'''
def divisors(x):
    d = []
    for j in range(1, x+1):
        if x % j == 0:
            d.append(j)
    return d

from fnmatch import *
for x in range(53,10**7,53):
    if fnmatch(str(x),"*2?2*"):
        if str(x) == str(x)[::-1]:
            d = divisors(x)
            if len(d) > 30:
                print(x, sum(d))
'''


# Идеальная функция поиска делителей числа для 25 номера
'''
def divisors(x):
    d = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            d.append(j)
            d.append(x // j)
    return sorted(set(d))


print(divisors(24))  # [1, 2, 3, 4, 6, 8, 12, 24]
print(divisors(1_000_000_000))
'''


# № 23763 Демоверсия 2026 (Уровень: Базовый)
# Пусть M – сумма минимального и максимального натуральных делителей
# целого числа, не считая единицы и самого числа.
# Если таких делителей у числа нет, то значение M признаётся равным нулю.
# Напишите программу, которая перебирает целые числа, бо́льшие 800 000,
# в порядке возрастания и ищет среди них такие, для которых
# M оканчивается на 4. В ответе запишите в первом столбце таблицы первые
# пять найденных чисел в порядке возрастания, а во втором столбце –
# соответствующие им значения M.
'''
def divisors(x):
    d = []
    for j in range(2, int(x**0.5)+1):  # не считая единицы и самого числа
        if x % j == 0:
            d.append(j)
            d.append(x // j)
    return sorted(set(d))

cnt = 0
for x in range(800_000+1, 10**10):
    d = divisors(x)
    if len(d) > 0:
        M = min(d) + max(d)
        if M % 10 == 4:
            print(x, M)
            cnt += 1
            if cnt == 5:
                break
'''


# № 23282 Основная волна 11.06.25 (Уровень: Средний)
# Пусть М - сумма минимального и максимального простых натуральных делителей
# целого числа, не считая самого числа. Если таких делителей у числа нет,
# то значение М считается равным нулю.
# Напишите программу, которая перебирает целые числа, большие 5 400 000,
# в порядке возрастания и ищет среди них такие, для
# которых М больше 60 000 и является палиндромом, т.е. одинаково читается
# слева направо и справа налево. В ответе запишите в первом столбце
# таблицы первые  пять найденных чисел в порядке возрастания, а во втором
# столбце - соответствующие им значения М.
'''
def divisors(x):
    d = []
    for j in range(2, int(x**0.5)+1):  # не считая единицы и самого числа
        if x % j == 0:
            d.append(j)
            d.append(x // j)
    return sorted(set(d))

cnt = 0
for x in range(5_400_000+1, 10**10):
    d = [j for j in divisors(x) if len(divisors(j)) == 0]
    if len(d) > 0:
        M = min(d) + max(d)
        if M > 60_000 and str(M) == str(M)[::-1]:
            print(x, M)
            cnt += 1
            if cnt == 5:
                break
'''


# № 21909 Открытый вариант 2025 (Уровень: Базовый)

# Пусть R – сумма всех различных натуральных делителей целого числа.
# Напишите программу, которая перебирает целые числа, бо́льшие 500 000,
# в порядке возрастания и ищет среди них такие, для которых
# значение R оканчивается на цифру 6. В ответе запишите в первом столбце таблицы
# первые пять найденных чисел в порядке возрастания, а во втором столбце – пять соответствующих этим числам значений R.
'''
def divisors(x):
    d = []
    for j in range(1, int(x ** 0.5) + 1): 
        if x % j == 0:
            d.append(j)
            d.append(x // j)
    return sorted(set(d))

cnt = 0
for x in range(500_000 + 1, 10 ** 6):
    d = divisors(x)
    if len(d) > 0:
        R = sum(d)
        if R % 10 == 6:
            print(x, R)
            cnt += 1
            if cnt == 5:
                break
'''


# № 21422 Досрочная волна 2025 (Уровень: Базовый)
# Напишите программу, которая перебирает целые числа, бóльшие 1 125 000, в порядке возрастания и ищет среди них такие, у которых
# есть натуральный делитель, оканчивающийся на цифру 7 и не равный ни самому числу, ни числу 7.
# В ответе запишите в первой строке таблицы первые пять найденных чисел в порядке возрастания,
# а во втором столбце – наименьший делитель для каждого из них, оканчивающийся цифрой 7, не равный ни самому числу, ни числу 7.

def divisors(x):
    d = []
    for j in range(1, int(x ** 0.5) + 1):
        if x % j == 0:
            d.append(j)
            d.append(x // j)
    return sorted(set(d))

cnt = 0
for x in range(1_125_000 + 1, 10 ** 10):
    d = [j for j in divisors(x) if j != 7 and j != x and j % 10 == 7]
    if len(d) > 0:
        print(x, min(d))
        cnt += 1
        if cnt == 5:
            break


# endregion Урок: *************************************************************
# #
# #
# ФИПИ = [1, 2, 4, 5, 7, 8, 9, 11, 13, 14, 15, 16, 17, 19-21, 23, 25]
# КЕГЭ = []
# на следующем уроке: 27
