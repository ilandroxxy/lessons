# region Домашка: ******************************************************************


# endregion Домашка: ******************************************************************
# #
# #
# region Урок: ********************************************************************

# № 21404 Досрочная волна 2025 (Уровень: Базовый)
# На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
# 1. Строится двоичная запись числа N.
# 2. Далее эта запись обрабатывается по следующему правилу:
# а) если сумма цифр в двоичной записи числа чётная,
# то к этой записи справа дописывается 0, а затем два левых разряда заменяются на 10;
# б) если сумма цифр в двоичной записи числа нечётная,
# то к этой записи справа дописывается 1, а затем два левых разряда заменяются на 11.
# Полученная таким образом запись является двоичной записью искомого числа R.

# Укажите минимальное число N, после обработки которого с помощью
# этого алгоритма получается число R, большее 480.
'''
for N in range(1, 10000):
    n = bin(N)[2:]
    # n = f'{N:b}'
    if sum(map(int, n)) % 2 == 0:
        n = "10" + n[2:] + "0"
    else:
        n = "11" + n[2:] + "1"
    r = int(n, 2)
    if r > 480:
        print(N)
        break
'''


# № 21473 (Уровень: Средний)
# (О. Лысенков) На вход алгоритма подаётся натуральное число N. Алгоритм строит по нему новое число R следующим образом.
# 1. Строится троичная запись числа N.
# 2. Далее эта запись обрабатывается по следующему правилу:
# а) если сумма цифр троичная записи кратна 4,
# то  все единицы в записи меняются на 2, а все 2 меняются на  единицы, после к числу приписывается 10 слева;
# б) если сумма цифр троичной записи не кратна 4,
# то к записи справа приписывается 20, после второй и третий разряд, полученной записи,
# меняются на  0 и 2 соответственно,
# разряды нумеруются слева направо, начиная с 1.
# Полученная таким образом запись является троичной записью искомого числа R.
#
# Укажите максимальное число N, для которого результатом
# работы алгоритма является наименьшее число R, превышающее 302.
'''
def c3(x):
    s = ""
    while x > 0:
        s = str(x % 3) + s
        x //= 3
    return s


l = []
for N in range(1, 10000):
    n = c3(N)
    if sum(map(int, n)) % 4 == 0:
        n = n.replace("1", "*")
        n = n.replace("2", "1")
        n = n.replace("*", "2")
        n = "10" + n
    else:
        n = n[0] + "02" + n[3:] + "20"
    r = int(n, 3)
    if r > 302:
        if r == 303:
            l.append(N)
# print(min(l))  # 303
print(max(l))
'''


# № 23764 Демоверсия 2026 (Уровень: Базовый)
# Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:
# – символ «?» означает ровно одну произвольную цифру;
# – символ «*» означает любую последовательность цифр произвольной длины;
# в том числе «*» может задавать и пустую последовательность.
# Среди натуральных чисел, не превышающих 10**10, найдите все числа,
# соответствующие маске 3?12?14*5, делящиеся на 1917 без остатка.
# В ответе запишите в первом столбце таблицы все найденные числа
# в порядке возрастания, а во втором столбце – соответствующие им
'''
from fnmatch import *
for x in range(1917, 10**10, 1917):
    if fnmatch(str(x), '3?12?14*5'):
        print(x, x//1917)

from re import *
for x in range(1917, 10**10, 1917):
    if fullmatch('3[0-9]12[0-9]14[0-9]+5', str(x)):
        print(x, x//1917)
'''

# № 14437 (Уровень: Средний)
'''
def divisors(x):
    d = []
    for i in range(2, int(x**0.5) + 1):
        if x % i == 0:
            d += [i, x // i]
    return sorted(set(d))

cnt = 0
for x in range(700_000, 1, -1):
    if cnt == 7: break
    d = divisors(x)
    if len(d):
        M = sum(d) // len(d)
        if M % 1000 == 313:
            cnt += 1
            print(x, M)
'''

# № 18192 (Уровень: Базовый)
'''
def divisors(x):
    d = []
    for i in range(2, int(x**0.5) + 1):
        if x % i == 0:
            d += [i, x // i]
    return sorted(set(d))


cnt = 0    
for x in range(1_000_000+1, 10**10):
    d = [j for j in divisors(x) if len(divisors(j)) == 0]
    if len(d) == 3:
        print(x, max(d))
        cnt += 1
        if cnt == 5: 
            break
'''


# № 23569 Пересдача 03.07.25 (Уровень: Средний)
# Напишите программу, которая перебирает целые числа,
# большие 6 086 055, в порядке возрастания и ищет среди них числа,
# представленные в виде произведено двух простых множителей,
# не обязательно различных, каждый из которых содержит
# в своей записи ровно одну цифру 6.
# В ответе в первом столбце таблицы запишите первые 5
# найденных чисел в порядке возрастания, а во втором столбце
# - для каждого из них соответствующий наибольший из найденных множителей.
# Количество строк в таблице для ответа избыточно.

from itertools import permutations

def divisors(x):
    d = []
    for i in range(1, int(x ** 0.5) + 1):
        if x % i == 0:
            d += [i, x // i]
    return sorted(d)

cnt = 0
for x in range(6_086_055+1, 10**10):
    d = [j for j in divisors(x) if len(divisors(j)) == 2 and '6' in str(j)]
    if len(d) > 0:
        if any(p[0] * p[1] == x for p in permutations(d, 2)):
            print(x, max(d))
            cnt += 1
            if cnt == 5:
                break





# endregion Урок: *************************************************************
# #
# #
# region Разобрать: *************************************************************


# endregion Разобрать: *************************************************************
# #
# #
# ФИПИ = [2, 5, 8, 9, 13, 14, 17, 25]
# КЕГЭ = []
# на следующем уроке: