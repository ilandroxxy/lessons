# region Домашка: ******************************************************************


# endregion Домашка: ******************************************************************
# #
# #
# region Урок: ********************************************************************


# № 23282 Основная волна 11.06.25 (Уровень: Средний)
# Пусть М - сумма минимального и максимального простых натуральных делителей
# целого числа, не считая самого числа. Если таких делителей у числа нет,
# то значение М считается равным нулю.
# Напишите программу, которая перебирает целые числа, большие 5 400 000,
# в порядке возрастания и ищет среди них такие, для которых
# М больше 60 000 и является палиндромом, т.е. одинаково читается слева
# направо и справа налево. В ответе запишите в первом столбце
# таблицы первые  пять найденных чисел в порядке возрастания,
# а во втором столбце - соответствующие им значения М.
'''
def divisors(x):
    d = []
    for j in range(2, int(x**0.5)+1):  # не считая самого числа (2 - исключил 1 и само число x)
        if x % j == 0:
            d += [j, x // j]
    return sorted(set(d))

cnt = 0
for x in range(5_400_000+1, 10**10):
    d = [j for j in divisors(x) if len(divisors(j)) == 0]
    if len(d) >= 2:
        M = min(d) + max(d)
        if M > 60_000 and str(M) == str(M)[::-1]:
            print(x, M)
            cnt += 1
            if cnt == 5:
                break
'''


# № 23382 Резервный день 19.06.25 (Уровень: Средний)
# Напишите программу, которая перебирает целые числа, большие 6 651 220,
# в порядке возрастания и ищет среди них числа, представленные в виде произведения
# ровно двух простых множителей, не обязательно различных, каждый из которых
# содержит в своей записи ровно одну цифру 2.
# В ответе в первом столбце таблицы запишите первые 5 найденных чисел в порядке возрастания,
# а во втором столбце - для каждого из чисел соответствующий им наибольший из найденных множителей.
'''
def is_prime(x):
    if x <= 1:
        return False
    for j in range(2, int(x**0.5)+1):
        if x % j == 0:
            return False
    return True

def divisors(x):
    d = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            if is_prime(j) and is_prime(x // j):
                if str(j).count('2') == 1 and str(x // j).count('2') == 1:
                    d += [j, x // j]
    return sorted(set(d))

cnt = 0
for x in range(6_651_220+1, 10**10):
    d = divisors(x)
    if len(d) > 0:
        print(x, max(d))
        cnt += 1
        if cnt == 5:
            break
'''


# № 26687 (Уровень: Средний)
# (А. Комков) Напишите программу, которая перебирает целые числа, большие 89427150,
# в порядке возрастания и ищет среди них те, которые можно представить
# в виде произведения 8 простых множителей (не обязательно различных), при этом выполняются оба условия:
# - среди простых множителей есть ровно две пары повторяющихся множителей, остальные множители различны.
# - минимальный простой множитель не повторяется.
# В ответе запишите первые 7 найденных чисел в порядке возрастания,
# а через пробел  для каждого из них соответствующий наибольший из найденных множителей.
'''
def is_prime(x):
    if x <= 1:
        return False
    for j in range(2, int(x**0.5)+1):
        if x % j == 0:
            return False
    return True

def divisors(x):
    d = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            if is_prime(j) and is_prime(x // j):
                if str(j).count('2') == 1 and str(x // j).count('2') == 1:
                    d += [j, x // j]
    return sorted(set(d))

# 2 * 4 * 2 * 4 *

cnt = 0
for x in range(89427150+1, 10**10):
    d = divisors(x)
    if len(d) > 0:
        print(x, max(d))
        cnt += 1
        if cnt == 5:
            break
'''

from fnmatch import *
from math import prod

def prost(x):
    if x <= 1:
        return False
    for i in range(2, int(x**0.5)+1):
        if x % i == 0:
            return False
    return True

for i in range(1, 10**7):
    if prost(i):
        if fnmatch(str(i), '31*567?'):
            print(i, prod([int(x) for x in str(i)]))


# endregion Урок: *************************************************************
# #
# #
# ФИПИ = [1, 2, 3, 5, 7, 8, 9, 11, 13, 14, 15, 16, 17, 18, 19-21, 22, 23, 25, 27]
# КЕГЭ = []
# на следующем уроке:
