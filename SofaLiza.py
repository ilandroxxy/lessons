# region Домашка: ******************************************************************


# endregion Домашка: ******************************************************************
# #
# #
# region Урок: ********************************************************************

# № 23764 Демоверсия 2026 (Уровень: Базовый)
# Назовём маской числа последовательность цифр, в которой также могут
# встречаться следующие символы:
# – символ «?» означает ровно одну произвольную цифру;
# – символ «*» означает любую последовательность цифр произвольной длины;
# в том числе «*» может задавать и пустую последовательность.

# Среди натуральных чисел, не превышающих 10**10, найдите все числа,
# соответствующие маске 3?12?14*5, делящиеся на 1917 без остатка.
# В ответе запишите в первом столбце таблицы все найденные числа
# в порядке возрастания, а во втором столбце – соответствующие им
# результаты деления этих чисел на 1917.
'''
from fnmatch import *
for x in range(1917, 10**10, 1917):
    if fnmatch(str(x), '3?12?14*5'):
        print(x, x // 1917)

from re import *
for x in range(1917, 10**10, 1917):
    if fullmatch('3[0-9]12[0-9]14[0-9]*5', str(x)):
        print(x, x // 1917)
'''



# Универсальная функция поиска делителей числа
'''
import time
start = time.time()

# def divisors(x):
#     d = []
#     for j in range(1, x+1):
#         if x % j == 0:
#             d.append(j)
#     return d


def divisors(x):
    d = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            d += [j, x // j]
            # d.append(j)
            # d.append(x // j)
    return sorted(set(d))

print(divisors(24))  # [1, 2, 3, 4, 6, 8, 12, 24]
print(divisors(16))  # [1, 2, 4, 8, 16]

print(divisors(1_000_000_000))

end = time.time()
print(end - start)  # 17.49530291557312 - 0.000998
'''


# № 23763 Демоверсия 2026 (Уровень: Базовый)
# Пусть M – сумма минимального и максимального натуральных делителей
# целого числа, не считая единицы и самого числа.
# Напишите программу, которая перебирает целые числа, бо́льшие 800 000,
# в порядке возрастания и ищет среди них такие, для которых
# M оканчивается на 4. В ответе запишите в первом столбце таблицы
# первые пять найденных чисел в порядке возрастания,
# а во втором столбце – соответствующие им значения M.
'''
def divisors(x):
    d = []
    # for j in range(1, int(x**0.5)+1):  # если нет ограничений на 1 и само число
    for j in range(2, int(x**0.5)+1):  # не считая единицы и самого числа
        if x % j == 0:
            d += [j, x // j]
    return sorted(set(d))

cnt = 0
for x in range(800_000+1, 10**10):
    d = divisors(x)
    if len(d) >= 2:
        M = min(d) + max(d)
        if M % 10 == 4:
            print(x, M)
            cnt += 1
            if cnt == 5:
                break
'''


# Обозначим через S сумму делителей целого числа, не считая самого числа.
# Если таких делителей у числа нет, то считаем значение S равным нулю.
# Напишите программу, которая перебирает целые числа, большие 32 500 000 в порядке
# возрастания и ищет среди них такие, для которых значение S не равно нулю и кратно 145.
#
# Программа должна найти первые 7 таких чисел. Для каждого из них в отдельной строке
# сначала выводится само число, затем значение S. Строки выводятся в порядке возрастания найденных чисел.
'''
def divisors(x):
    d = []
    for j in range(2, int(x**0.5)+1):
        if x % j == 0:
            d += [j, x // j]
    return sorted(set(d))

cnt = 0
for x in range(32_500_000+1, 10**10):
    d = divisors(x)
    if len(d) > 0:
        S = sum(d)
        if S > 0 and S % 145 == 0:
            print(x, S)
            cnt += 1
            if cnt == 7:
                break
'''


# № 19775 (Уровень: Средний)
# Обозначим через S сумму простых делителей целого числа, не считая самого числа.
# Если таких делителей у числа нет, то считаем значение S равным нулю.
# Напишите программу, которая перебирает целые числа, большие 32 500 000 в порядке
# возрастания и ищет среди них такие, для которых значение S не равно нулю и кратно 145.
#
# Программа должна найти первые 7 таких чисел. Для каждого из них в отдельной строке
# сначала выводится само число, затем значение S. Строки выводятся в порядке возрастания найденных чисел.
'''
def divisors(x):
    d = []
    for j in range(2, int(x**0.5)+1):
        if x % j == 0:
            d += [j, x // j]
    return sorted(set(d))

cnt = 0
for x in range(32_500_000+1, 10**10):
    d = [j for j in divisors(x) if len(divisors(j)) == 0]
    if len(d) > 0:
        S = sum(d)
        if S > 0 and S % 145 == 0:
            print(x, S)
            cnt += 1
            if cnt == 7:
                break
'''


# № 17642 Основная волна 19.06.24 (Уровень: Базовый)
# Напишите программу, которая перебирает целые числа, большие 800000,
# в порядке возрастания и ищет среди них такие, у которых есть натуральный делитель,
# оканчивающийся на цифру 9 и не равный ни самому числу, ни числу 9.
# В ответе запишите в первом столбце таблицы первые пять найденных чисел
# в порядке возрастания, а во втором столбце — соответствующий минимальный
# делитель для каждого числа, оканчивающийся цифрой 9, не равный
# ни самому числу, ни числу 9.
'''
def divisors(x):
    d = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            d += [j, x // j]
    return sorted(set(d))

cnt = 0
for x in range(800_000+1, 10**10):
    d = [j for j in divisors(x) if j % 10 == 9 and j != x and j != 9]
    if len(d) > 0:
        print(x, min(d))
        cnt += 1
        if cnt == 5:
            break
'''


# № 23282 Основная волна 11.06.25 (Уровень: Средний)
# Пусть М - сумма минимального и максимального простых натуральных делителей
# целого числа, не считая самого числа. Если таких делителей у числа нет,
# то значение М считается равным нулю.
# Напишите программу, которая перебирает целые числа, большие 5 400 000, в порядке
# возрастания и ищет среди них такие, для которых М больше 60 000 и является палиндромом,
# т.е. одинаково читается слева направо и справа налево. В ответе запишите в первом столбце
# таблицы первые  пять найденных чисел в порядке возрастания, а во втором столбце
# - соответствующие им значения М.
'''
def divisors(x):
    d = []
    for j in range(2, int(x**0.5)+1):
        if x % j == 0:
            d += [j, x // j]
    return sorted(set(d))

cnt = 0
for x in range(5_400_000+1, 10**10):
    d = [j for j in divisors(x) if len(divisors(j)) == 0]
    if len(d) > 0:
        M = min(d) + max(d)
        if M > 60_000 and str(M) == str(M)[::-1]:
            print(x, M)
            cnt += 1
            if cnt == 5:
                break
'''



# № 23382 Резервный день 19.06.25 (Уровень: Средний)
# Напишите программу, которая перебирает целые числа, большие 6 651 220,
# в порядке возрастания и ищет среди них числа, представленные в виде
# произведения ровно двух простых множителей, не обязательно различных,
# каждый из которых содержит в своей записи ровно одну цифру 2.
# В ответе в первом столбце таблицы запишите первые 5 найденных чисел
# в порядке возрастания, а во втором столбце - для каждого из чисел
# соответствующий им наибольший из найденных множителей.
'''
def prime_at_divisors(x):
    d = []
    for j in range(2, int(x**0.5)+1):
        if x % j == 0:
            d += [j, x // j]
    return sorted(set(d))

def divisors(x):
    d = []
    for j in range(2, int(x**0.5)+1):
        if x % j == 0:
            if len(prime_at_divisors(j)) == 0 and len(prime_at_divisors(x // j)) == 0:
                if str(j).count('2') == 1 and str(x // j).count('2') == 1:
                    d += [j, x // j]
    return sorted(d)

cnt = 0
for x in range(6_651_220+1, 10**10):
    d = divisors(x)
    if len(d) >= 2:
        print(x, max(d))
        cnt += 1
        if cnt == 5:
            break
'''

# Вариант 2
'''
def prime(x):
    if x <= 1:
        return False
    for j in range(2, int(x**0.5)+1):
        if x % j == 0:
            return False
    return True

def divisors(x):
    d = []
    for j in range(2, int(x**0.5)+1):
        if x % j == 0:
            if prime(j) and prime(x // j):
                if str(j).count('2') == 1 and str(x // j).count('2') == 1:
                    d += [j, x // j]
    return sorted(d)

cnt = 0
for x in range(6_651_220+1, 10**10):
    d = divisors(x)
    if len(d) >= 2:
        print(x, max(d))
        cnt += 1
        if cnt == 5:
            break
'''


# endregion Урок: *************************************************************
# #
# #
# ФИПИ = [1, 2, 3, 5, 8, 13, 14, 15, 16, 19-21, 23, 25]
# КЕГЭ = []
# на следующем уроке: 17, 9, 27
