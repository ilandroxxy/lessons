# region Домашка: ******************************************************************

# № 14360 (Уровень: Базовый)
# Для узла с IP-адресом 153.202.16.37 адрес сети равен 153.202.16.32.
# Определите наибольшее возможное значение суммы последних двух байтов маски.
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'153.202.16.37/{mask}', 0)
    if '153.202.16.32' in str(net):
        print(net, mask, net.netmask)

print(255 + 248)

# 153.202.16.32/27 27 255.255.255.224 11111111.11111111.11111111.11100000
# 153.202.16.32/28 28 255.255.255.240 11111111.11111111.11111111.11110000
# 153.202.16.32/29 29 255.255.255.248 11111111.11111111.11111111.11111000
'''
from idlelib.run import flush_stdout

# № 11769 (Уровень: Базовый)
# Для узла с IP-адресом 157.17.164.129 адрес сети равен 157.17.128.0.
# Чему равно наименьшее возможное значение третьего слева байта маски?
'''
from ipaddress import *
for mask in range(32+1):
    net = ip_network(f'157.17.164.129/{mask}', 0)
    if '157.17.128.0' in str(net):
        print(net.netmask)
'''


# № 10786 (Уровень: Средний)
# Два узла, находящиеся в разных подсетях, имеют
# IP-адреса 151.172.115.121 и 151.172.115.156.
# В масках обеих подсетей одинаковое количество единиц.
# Укажите наименьшее возможное количество единиц в масках этих подсетей.
'''
from ipaddress import *
for mask in range(32+1):
    net1 = ip_network(f'151.172.115.121/{mask}', 0)
    net2 = ip_network(f'151.172.115.156/{mask}', 0)
    if net1 != net2:
        print(mask)
'''

# endregion Домашка: ******************************************************************
# #
# #
# region Урок: ********************************************************************

# № 23764 Демоверсия 2026 (Уровень: Базовый)
# Среди натуральных чисел, не превышающих 10**10,
# найдите все числа, соответствующие маске 3?12?14*5,
# делящиеся на 1917 без остатка.
'''
# Вариант 1
from fnmatch import *
for x in range(1917, 10**10, 1917):
    if fnmatch(str(x), '3?12?14*5'):
        print(x, x // 1917)


# Вариант 2
from re import *
for x in range(1917, 10**10, 1917):
    if fullmatch('3[0-9]12[0-9]14[0-9]*5', str(x)):
        print(x, x // 1917)
'''


# № 7689 (Уровень: Средний)
'''
from re import *
for x in range(1323, 3*10**8, 1323):
    if x % 780 == 0:
        if fullmatch('[0-9]*[02468]32[0-9][0-9]', str(x)):
            print(x, x // 780)
'''


# Универсальная функция перевода:
'''
def divisors(x):
    d = []
    for j in range(2, int(x**0.5)+1):
        if x % j == 0:
            d += [j, x // j]
    return sorted(set(d))


print(divisors(24))  # [1, 2, 3, 4, 6, 8, 12, 24]
print(divisors(16))  # [1, 2, 4, 8, 16]


# Не считая единицы и самого числа
def divisors(x):
    d = []
    for j in range(2, int(x**0.5)+1):
        if x % j == 0:
            d += [j, x // j]
    return sorted(set(d))

print(divisors(24))  # [2, 3, 4, 6, 8, 12]
print(divisors(16))  # [2, 4, 8]
'''


# № 23763 Демоверсия 2026 (Уровень: Базовый)
'''
def divisors(x):
    d = []
    for j in range(2, int(x**0.5)+1):  # 2 - не считая единицы и самого числа
        if x % j == 0:
            d += [j, x // j]
    return sorted(set(d))


cnt = 0
for x in range(800_000+1, 10**10):
    d = divisors(x)
    if len(d) > 0:
        M = min(d) + max(d)
        if M % 10 == 4:
            print(x, M)
            cnt += 1
            if cnt == 5:
                break
'''

# № 21909 Открытый вариант 2025 (Уровень: Базовый)
'''
def divisors(x):
    d = []
    for j in range(1, int(x**0.5)+1):
        if x % j == 0:
            d += [j, x // j]
    return sorted(set(d))

cnt = 0
for x in range(500_000+1, 10**10):
    d = divisors(x)
    if len(d) > 0:
        R = sum(d)
        if R % 10 == 6:
            print(x, R)
            cnt += 1
            if cnt == 5:
                break
'''


# № 17879 Демоверсия 2025 (Уровень: Базовый)
# Пусть M – сумма минимального и максимального натуральных делителей целого числа, не считая единицы и самого числа.

# Если таких делителей у числа нет, то считаем значение M равным нулю.
# Напишите программу, которая перебирает целые числа, бо́льшие 800 000, в порядке возрастания
# и ищет среди них такие, для которых M оканчивается на 4.

# В ответе запишите в первом столбце таблицы первые пять найденных чисел в порядке возрастания,
# а во втором столбце – соответствующие им значения M.


def divisors(x):
    d = []
    for j in range(2, int(x ** 0.5) + 1):
        if x % j == 0:
            d += [j, x // j]
    return sorted(set(d))


cnt = 0
for x in range(800_000 + 1, 10 ** 10):
    d = divisors(x)
    if len(d) > 0:
        M = min(d) + max(d)
        if M % 10 == 4:
            print(x, M)
            cnt += 1
            if cnt == 5:
                break


# № 17564 Основная волна 08.06.24 (Уровень: Средний)

# Пусть М – сумма минимального и максимального натуральных делителей целого числа, не считая единицы и самого числа.
# Если таких делителей у числа нет, то считаем значение М равным нулю.
# Напишите программу, которая перебирает целые числа, большие 700 000, в порядке возрастания
# и ищет среди них такие, для которых  М оканчивается на 4.

# В ответе запишите в первом столбце таблицы первые пять найденных чисел в порядке возрастания,
# а во втором  столбце - соответствующие им значения М.

def divisors(x):
    d = []
    for j in range(2, int(x ** 0.5) + 1):
        if x % j == 0:
            d += [j, x // j]
    return sorted(set(d))


cnt = 0
for x in range(700_000 + 1, 10 ** 10):
    d = divisors(x)
    if len(d) > 0:
        M = min(d) + max(d)
        if M % 10 == 4:
            print(x, M)
            cnt += 1
            if cnt == 5:
                break


# endregion Урок: *************************************************************
# #
# #
# region Разобрать: *************************************************************


# endregion Разобрать: *************************************************************
# #
# #
# ФИПИ = [2, 5, 6, 8, 13.1, 14, 25]
# КЕГЭ = []
# на следующем уроке:
